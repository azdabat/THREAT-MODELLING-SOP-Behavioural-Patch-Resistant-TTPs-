# Threat Modelling SOP – Rust4Shell + EtherRAT  
Author: **Ala Dabat (azdabat)**  
Version: **2025-L3**  

This SOP defines **reproducible steps** to model these threats, from initial access to persistence, while enabling hunters to specify which telemetry, rules, and enrichments are needed at each stage.

---

## 1. Scope & Objectives
- Model **Rust4Shell**: a server‑side exploit enabling arbitrary command execution.  
- Model **EtherRAT**: a modern implant leveraging supply chains, IDE abuse, and blockchain RPC for C2.  
- Goal: produce behavioural detection hunts with minimal noise, maximised fidelity, and clear hunter directives.

---

## 2. Threat Surface Enumeration
List all entry points and vectors for each threat.

### Rust4Shell
- Public‑facing web servers (Rust or other frameworks).  
- Deserialization or SSR endpoints that accept complex payloads.  
- HTTP(S) endpoints used by clients or internal services.

### EtherRAT
- IDE / Extension supply chain.  
- Web or Cloud developer endpoints.  
- Staged or downloaded loaders from unknown sources.

---

## 3. Behavioural Decomposition by Stage
Break the attack into distinct phases; each phase becomes rule(s) or enrichment for a broader rule.

### Stage 0 — Initial Access
- Rust4Shell exploit; detection via web → shell pivot.

### Stage 1 — Tooling staging
- Pipe‑to‑shell, web downloads; detection via staging hunts.

### Stage 2 — Obfuscation & evasion
- Base64, AMSI bypass; detection via obfuscation hunts.

### Stage 3 — Secrets discovery
- Search for passwords/tokens; detection via secrets recon hunts.

### Stage 4 — Loader / userland execution
- Unsigned binaries, Rust loaders; detection via userland loader hunts.

### Stage 5 — IDE / Extension abuse
- Extension‐driven execution or payload drop; detection via IDE abuse, file drop, persistence hunts.

### Stage 6 — C2 beacon
- Blockchain RPC / Web3; detection via RPC hunts and correlation.

### Stage 7 — Persistence / lateral movement
- Extension config modifications, scheduled task or registry changes (optional); detection via persistence hunts and follow‑on correlation.

---

## 4. Telemetry Mapping
Identify required tables per stage.

| Stage | Telemetry | Purpose |
|---|---|---|
| 0 | DeviceProcessEvents | Web → Shell pivot detection |
| 1 | DeviceProcessEvents | Staging behaviour detection |
| 2 | DeviceProcessEvents | Obfuscation / AMSI detection |
| 3 | DeviceProcessEvents | Secrets discovery |
| 4 | DeviceProcessEvents | Loader execution, Unsigned binary detection |
| 5 | DeviceFileEvents + DeviceProcessEvents + DeviceImageLoadEvents | File drop, execution, ghost module load |
| 6 | DeviceNetworkEvents | RPC C2 beacon detection |
| 7 | DeviceFileEvents + DeviceRegistryEvents | Persistence detection |

---

## 5. Fidelity Assessment
Score behaviours for signal vs noise.

| Stage | Fidelity | Reason |
|---|---|---|
| 0 | Very High | Web → Shell rarely benign |
| 1 | High | Pipe‑to‑shell rare; some noise from CI/CD |
| 2 | Very High | AMSI bypass rarely benign; strong intent |
| 3 | High | Sensitive keywords; some noise if misconfigured filters |
| 4 | High | Unsigned + user path; some dev noise |
| 5 | High | Extension abuse rare in non‑dev hosts; some dev noise suppressed |
| 6 | Medium‑High | RPC noisy alone; strong when correlated |
| 7 | Medium | Requires context; still critical if seen |

---

## 6. Segmentation Decision
Segment into smaller hunts rather than one monolithic rule to avoid noise and failures.

- **High‑fidelity, low‑noise rules**: Web → Shell, Obfuscation, IDE abuse with ghost load, Secrets recon.
- **Medium‑noise but high‑value rules**: RPC, File drop, Persistence.
- **Correlators**: IDE abuse → RPC; chain multiple rules for P1 decisions.

---

## 7. Scoring & Directives
For each rule, use a **risk score** combining multiple signals (shell type, flags, context, path, etc.). Map score to **Severity** and produce **HunterDirective** for action.

- Thresholds set to lift only highest risk to P1.
- Use negative weights for known benign scenarios rather than hard excludes when possible.

---

## 8. Attack Chain Correlation Plan
Design correlation hunts to connect the stages:

- **Rust4Shell chain**: Stage 0 → 1 → 2 → 3 → 4.
- **EtherRAT chain**: Stage 4 → 5 → 6 → 7.
- **Unified chain**: Connect both via file drops, IDE extensions, and RPC.

Use time windows (e.g., 24h) to correlate across hunts and devices.

---

## 9. Integration with MITRE
Always annotate each rule’s output with MITRE tactics/techniques for reporting, dashboards, and training.

- Use T1190 for initial exploitation references.
- Use T1102 for web service C2 and mapping to RPC use.
- Use T1562.001 and T1027 for obfuscation and bypass.  
- Use T1081/T1552 for secrets discovery.
- Use T1195/T1547 for supply chain and persistence.

---

## 10. Review & Tuning Cycle
- After deployment, gather stats: false positives, true positives, analysts’ time-to-action.
- Adjust thresholds and exclusion lists (e.g., benign toolchains, integrated terminal).
- Add additional behaviours or paths once new techniques are observed in the wild.

---

## 11. Training & Documentation
- Ensure each rule includes **clear hunter directives** and risk explanation.
- Train SOC tiers on what each severity means, when to escalate.
- Maintain diagrams, SOPs, and MITRE mapping; update for new findings.

---

# End – Threat Modelling SOP
