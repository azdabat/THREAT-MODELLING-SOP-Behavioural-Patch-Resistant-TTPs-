// ============================================================================
// L3_ReactDevServer_PostExploitation_Chain — ANALYTIC MODE (Alert-Safe)
// Author: Ala Dabat
// Version: 2025-12 (L3 Analytic)
// Platforms: Windows + Linux (MDE Advanced Hunting / Sentinel Analytic)
// Purpose:
//   Production-ready analytic with tenant-toggle allowlisting to reduce FPs.
//   Alerts on high-confidence post-exploitation chains from web/runtime parents.
//
// Design Note (Truth in Telemetry):
//   In-memory exploitation (HMR/eval/vm.runInThisContext) is not reliably visible.
//   This analytic detects *post-exploitation side-effects* (proc/net/file).
//
// MITRE:
//   TA0002 Execution          (T1059, T1203, T1059.003)
//   TA0003 Persistence        (T1543, T1053)
//   TA0005 Defense Evasion    (T1027, T1218)
//   TA0011 Command and Control(T1071, T1105)
// ============================================================================

let lookback = 7d;
let ChainWindow = 10m;

// ----------------------------
// ANALYTIC MODE: ALLOWLIST ON
// ----------------------------
let EnableAllowlist = true;

// Tenant-specific allowlists (edit arrays per tenant; keep logic stable)
let AllowedParentCmdlinePatterns = dynamic([
  "npm install","npm ci","npm run build",
  "yarn install","yarn build",
  "pnpm install","pnpm build",
  "webpack","vite","react-scripts","next build",
  "gulp","grunt"
]);

let AllowedPaths = dynamic([
  "\\agent\\_work\\",              // Azure DevOps
  "\\actions\\runner\\",           // GitHub Actions (Windows)
  "/home/runner/",                 // GitHub Actions (Linux)
  "/opt/hostedtoolcache/",
  "/var/lib/jenkins/",
  "/build/",
  "/workspace/"
]);

let AllowedAccounts = dynamic([
  "svc-azure-devops",
  "svc-github-runner",
  "svc-jenkins",
  "buildagent",
  "runner"
]);

// Runtime/Web parents
let ParentProc = dynamic([
  "node.exe","node",
  "w3wp.exe","iisexpress.exe",
  "httpd.exe","nginx.exe",
  "java.exe","java",
  "dotnet.exe","dotnet",
  "gunicorn","uwsgi"
]);

// Suspicious child processes (shells + LOLBins + network tools)
let ChildProc = dynamic([
  "powershell.exe","pwsh.exe","cmd.exe",
  "mshta.exe","wscript.exe","cscript.exe",
  "rundll32.exe","regsvr32.exe","certutil.exe",
  "msbuild.exe","csc.exe","installutil.exe","msiexec.exe",
  "sh","bash","dash","zsh",
  "python","python3","perl","php","ruby",
  "curl","wget","nc","ncat","socat","ssh"
]);

let StagingSignals = dynamic([
  "Invoke-Expression","IEX","Invoke-WebRequest","EncodedCommand","FromBase64String",
  "AmsiScanBuffer","AmsiUtils","System.Management.Automation",
  "curl http","wget http","curl|bash","curl | bash","wget -O - | bash",
  "bash -c","sh -c",
  "child_process.exec","child_process.spawn","vm.runInThisContext","eval("
]);

let SensitiveFileHints = dynamic([
  ".env",".npmrc",".aws/credentials",".ssh/id_rsa","config.json","id_rsa","known_hosts",
  ".bashrc",".zshrc",".profile"
]);

let MaliciousExtensions = dynamic([
  ".ps1",".bat",".cmd",".vbs",".js",".jse",".sh",".py",".pl",".php",".jar",".jsp",
  ".exe",".dll",".so"
]);

// Allowlist predicate (applies only when EnableAllowlist=true)
// NOTE: FolderPath only exists in file events; for process events we use parent cmdline + account.
let IsAllowlistedProc = (
  EnableAllowlist
  and (
    InitiatingProcessCommandLine has_any (AllowedParentCmdlinePatterns)
    or AccountName has_any (AllowedAccounts)
  )
);

let IsAllowlistedFile = (
  EnableAllowlist
  and (
    InitiatingProcessCommandLine has_any (AllowedParentCmdlinePatterns)
    or AccountName has_any (AllowedAccounts)
    or FolderPath has_any (AllowedPaths)
  )
);

// ---------------------------------------------------------------------------
// 1) PROC (Analytic): Gate on higher confidence process behaviors
//    - Excludes allowlisted build activity
//    - Requires meaningful score before continuing
// ---------------------------------------------------------------------------
let Proc =
DeviceProcessEvents
| where Timestamp >= ago(lookback)
| where InitiatingProcessFileName has_any (ParentProc)
| where FileName has_any (ChildProc)
| where not(IsAllowlistedProc)
| extend Cmd = tostring(ProcessCommandLine)
| extend HasStaging = Cmd has_any (StagingSignals)
| extend HasPipeToShell = Cmd matches regex @"(curl\s+\S+.*\|\s*(ba|z|da)?sh)|(wget\s+.+\|\s*(ba|z|da)?sh)"
| extend B64 = extract_all(@"[A-Za-z0-9+/]{40,}={0,2}", Cmd)
| extend HasB64 = array_length(B64) > 0
| extend ProcScore =
    40
  + iif(HasStaging, 30, 0)
  + iif(HasPipeToShell, 45, 0)
  + iif(HasB64, 15, 0)
| where ProcScore >= 60
| project
    ProcTs=Timestamp, DeviceId, DeviceName, AccountName,
    Parent=InitiatingProcessFileName, ParentCmd=InitiatingProcessCommandLine,
    Child=FileName, Cmd, ProcScore, HasStaging, HasPipeToShell, HasB64;

// ---------------------------------------------------------------------------
// 2) NET (Analytic): Score external high-risk patterns (C2-ish)
// ---------------------------------------------------------------------------
let Net =
DeviceNetworkEvents
| where Timestamp >= ago(lookback)
| where InitiatingProcessFileName has_any (ParentProc)
| where ActionType in ("ConnectionSuccess","InboundConnectionAccepted","ListeningConnectionCreated")
| extend Remote = coalesce(RemoteUrl, RemoteIP)
| extend RemoteUrlIndicators = RemoteUrl has_any (dynamic(["pastebin","discord","telegram","ngrok","trycloudflare","onion"]))
| extend RemoteIpNonPrivate = iff(isnotempty(RemoteIP), not(ipv4_is_private(RemoteIP)), bool(null))
| extend HighRiskPort = RemotePort in (4444, 1337, 2222, 3001, 4443, 8080, 8443, 9001, 31337)
| extend NetScore =
    20
  + iif(RemoteUrlIndicators, 20, 0)
  + iif(HighRiskPort and RemoteIpNonPrivate == true, 35, 0)
| project
    NetTs=Timestamp, DeviceId, DeviceName, AccountName,
    Parent=InitiatingProcessFileName, ParentCmd=InitiatingProcessCommandLine,
    RemoteIP, RemotePort, RemoteUrl, LocalPort, Protocol, ActionType, NetScore;

// ---------------------------------------------------------------------------
// 3) FILE (Analytic): Heavier weighting for sensitive targets + payload-like writes
// ---------------------------------------------------------------------------
let Files =
DeviceFileEvents
| where Timestamp >= ago(lookback)
| where InitiatingProcessFileName has_any (ParentProc)
| where ActionType in ("FileCreated","FileModified","FileRenamed")
| where not(IsAllowlistedFile)
| extend Path = tostring(FolderPath)
| extend Name = tostring(FileName)
| extend HasSensitiveName = Name has_any (SensitiveFileHints)
| extend HasMaliciousExt = Name has_any (MaliciousExtensions)
| extend HasTempOrHidden =
    Path has_any (dynamic(["\\Temp\\","\\AppData\\Local\\Temp\\","/tmp/","/var/tmp/","/.cache/"]))
    or Name startswith "."
| extend FileScore =
    10
  + iif(HasSensitiveName, 55, 0)
  + iif(HasMaliciousExt and HasTempOrHidden, 35, 0)
| project
    FileTs=Timestamp, DeviceId, DeviceName, AccountName,
    Parent=InitiatingProcessFileName, ParentCmd=InitiatingProcessCommandLine,
    FolderPath, FileName, FileScore, HasSensitiveName, HasTempOrHidden, HasMaliciousExt;

// ---------------------------------------------------------------------------
// 4) CHAIN (Analytic): Correlate to a single record and apply severity gating
// ---------------------------------------------------------------------------
Proc
| join kind=leftouter (Net) on DeviceId, AccountName, Parent
| where NetTs between (ProcTs - ChainWindow .. ProcTs + ChainWindow) or isempty(NetTs)
| join kind=leftouter (Files) on DeviceId, AccountName, Parent
| where FileTs between (ProcTs - ChainWindow .. ProcTs + ChainWindow) or isempty(FileTs)
| extend TotalScore = ProcScore + coalesce(NetScore,0) + coalesce(FileScore,0)
| extend ChainBucket = bin(ProcTs, ChainWindow)
| summarize
    FirstSeen=min(ProcTs),
    LastSeen=max(ProcTs),
    Parents=make_set(Parent, 5),
    ParentCmds=make_set(ParentCmd, 10),
    Children=make_set(Child, 25),
    CommandLines=make_set(Cmd, 25),
    Remotes=make_set(coalesce(RemoteUrl, RemoteIP), 25),
    RemotePorts=make_set(tostring(RemotePort), 25),
    FileTouches=make_set(strcat(FolderPath,"\\",FileName), 25),
    MaxScore=max(TotalScore),
    Signals=make_set(
      strcat(
        iif(HasStaging,"Staging;",""),
        iif(HasPipeToShell,"PipeToShell;",""),
        iif(HasB64,"Base64;",""),
        iif(HasSensitiveName,"SensitiveFileName;",""),
        iif(HasTempOrHidden,"TempOrHiddenWrite;",""),
        iif(HasMaliciousExt,"MaliciousExtensionWrite;","")
      ), 10
    )
  by ChainBucket, DeviceName, AccountName
| extend Severity = case(
    MaxScore >= 115, "CRITICAL",
    MaxScore >= 85,  "HIGH",
    MaxScore >= 55,  "MEDIUM",
    "LOW"
)
| where Severity in ("CRITICAL","HIGH","MEDIUM")
| extend HuntingDirectives = case(
    Severity == "CRITICAL",
      "CRITICAL: Treat as likely compromise. Validate runtime parent + child shell/LOLBins + confirm external C2/exfil or sensitive file touches. Recommend isolate host, scope blast radius, rotate secrets.",
    Severity == "HIGH",
      "HIGH: Confirm not allowlisted CI/dev tooling. Pivot to persistence (cron/systemd/services/tasks), check secrets access (.env/.ssh), and review outbound connections. Escalate if corroborated.",
    "MEDIUM: Needs corroboration. Validate expected dev/build activity for tenant; pivot to net/file evidence. If repeated chains or external high-risk ports present, escalate."
)
| order by FirstSeen desc
;

// ============================================================================
// INCIDENT RESPONSE FRAMEWORK — React / Node.js Runtime Post-Exploitation
// Commented for analyst guidance only (non-executing)
// ============================================================================
//
// PHASE 1 — TRIAGE & VALIDATION (L2/L3)
// 1) Confirm parent context (node/w3wp/java/dotnet) + host role (prod vs dev vs CI).
// 2) Validate child intent: shell/LOLBins, pipe-to-shell, base64, staging keywords.
// 3) Corroborate: outbound connections (esp. non-private + high-risk ports) + file writes.
//
// PHASE 2 — SCOPING & THREAT ASSESSMENT
// 4) Scope DeviceId: additional suspicious children, repeated ChainBucket hits, new remotes.
// 5) Scope AccountName: service acct misuse, lateral patterns on other hosts.
// 6) Privilege check: runtime running as root/SYSTEM; container breakout risk.
//
// PHASE 3 — CONTAINMENT
// 7) Isolate if any: confirmed C2/reverse shell, sensitive secrets touched, persistence found.
// 8) Block exposure: stop dev servers, restrict inbound ports, tighten SG/WAF, remove public routes.
//
// PHASE 4 — ERADICATION & REMEDIATION
// 9) Persistence removal: cron/systemd/services/tasks/startup scripts; remove dropped payloads.
// 10) Rotate secrets: .env, API keys, cloud creds, SSH keys; invalidate tokens.
// 11) Harden: never expose dev servers; disable HMR off-host; enforce allowlists + auth.
//     - Prefer VPN/SSO + IP allowlists for dev tooling.
//     - Ensure containers run as non-root where possible.
//
// PHASE 5 — POST-INCIDENT
// 12) Tune allowlists per tenant: approved runners, build paths, service accounts.
// 13) Capture IOCs/TTPs; feed into threat hunting backlog + SDLC guardrails.
// ============================================================================
