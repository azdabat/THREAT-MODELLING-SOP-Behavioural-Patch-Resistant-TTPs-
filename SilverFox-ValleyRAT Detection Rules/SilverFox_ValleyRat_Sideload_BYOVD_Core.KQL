//////////////////////////////////////////////////////////////////////////////////
// SilverFox_ValleyRat_Sideload_BYOVD_Core (Improved / Final Detection)
// Author: Ala Dabat
// Version: 2025-12 (Rev2)
// WORK IN PROGRESS
// PURPOSE
// Behavioural correlation hunt for SilverFox/ValleyRAT-style chains where a:
//   Signed/legitimate loader → loads untrusted module (sideload) from writable path
//   → stages driver-like artifact (often .sys OR disguised .dat/.bin/.tmp)
//   → registers kernel service (registry/API/SC/PowerShell/WMI/PnP methods)
//   → (NEW) confirms actual kernel driver load (DriverLoadEvent ground truth)
//
// WHY THESE CORRECTIONS (from DeepSeek/Gemini feedback)
// - Sideload payloads may not end in .dll (can be .dat/.bin/.ocx/.cpl/renamed)
// - Service creation frequently uses registry/API/PowerShell/WMI, not only sc.exe
// - BYOVD still must result in an actual kernel driver load; add DriverLoadEvent join
// - Keep it behavioural: avoid hash lists; focus on “signed trust abused in wrong places”
//
// TABLES
// DeviceImageLoadEvents, DeviceFileEvents, DeviceRegistryEvents, DeviceProcessEvents, DeviceEvents
//
// MITRE
// T1574.002 DLL Side-Loading | T1543.003 Windows Service | T1068 Priv Esc (BYOVD)
// T1562.001 Disable/Modify Tools | T1027 Obfuscated/Disguised Artifacts
//////////////////////////////////////////////////////////////////////////////////

let Lookback = 24h;

// Time windows remain staged but less brittle than ultra-tight chaining
let SideloadToDropWindow = 6h;   // was 45m; real chains can be longer
let DropToServiceWindow  = 2h;   // was 15m; allow more realistic delays
let ServiceToKernelWindow = 2h;  // kernel load may occur after persistence write

let WritablePaths = dynamic(["\\Temp\\","\\ProgramData\\","\\Users\\","\\Public\\","\\Desktop\\","\\Downloads\\","\\AppData\\"]);

// Broaden “module” and “driver-like” extensions (behavioural staging)
let ModuleExtRegex = @"\.(dll|ocx|cpl|dat|bin|tmp)$";
let DriverExtRegex = @"\.(sys|drv|dat|bin|tmp|ax)$";

// 1) SIDELOAD (behavioural):
// Signed loader in writable path loads an untrusted/mismatched module from the SAME writable folder.
let SideloadEvents =
DeviceImageLoadEvents
| where Timestamp > ago(Lookback)
| where InitiatingProcessFolderPath has_any (WritablePaths)
| where FolderPath == InitiatingProcessFolderPath
| where InitiatingProcessSignatureStatus == "Signed"
| where FileName matches regex ModuleExtRegex
// Signature drift: loaded module unsigned OR signer differs from loader signer
| where (SignatureStatus != "Signed" or Signer != InitiatingProcessSigner)
| project
    DeviceId,
    SideloadTime = Timestamp,
    LoaderName   = InitiatingProcessFileName,
    LoaderPath   = InitiatingProcessFolderPath,
    LoaderPid    = InitiatingProcessId,
    LoaderSigner = tostring(InitiatingProcessSigner),
    LoadedModule = FileName,
    LoadedModulePath = FolderPath,
    LoadedSigner = tostring(Signer),
    LoadedSigStatus = tostring(SignatureStatus);

// 2) DRIVER-LIKE DROP into writable path (drivers are often disguised)
let DriverDrops =
DeviceFileEvents
| where Timestamp > ago(Lookback)
| where ActionType in ("FileCreated","FileModified","FileRenamed","FileMoved")
| where FolderPath has_any (WritablePaths)
| where FileName matches regex DriverExtRegex
| project
    DeviceId,
    DropTime = Timestamp,
    DriverFile = FileName,
    DriverFolder = FolderPath,
    DropperPid = InitiatingProcessId,
    DropperProc = InitiatingProcessFileName,
    DropperCmd  = InitiatingProcessCommandLine;

// 3) SERVICE CREATION (catch registry/API + common process methods)
//
// 3a) Registry/API (strongest behavioural anchor)
let ServiceRegistry =
DeviceRegistryEvents
| where Timestamp > ago(Lookback)
| where RegistryKey has @"System\CurrentControlSet\Services"
| where RegistryValueName == "ImagePath"
| where RegistryValueData has_any (WritablePaths)
| where RegistryValueData matches regex @"\.(sys|drv|dat|bin|tmp|dll)$"
| project
    DeviceId,
    ServiceTime = Timestamp,
    ServiceIndicator = RegistryKey,
    ServiceValue = RegistryValueData,
    ServicePid = InitiatingProcessId,
    Method = "Registry/API";

// 3b) Process methods (wider than sc.exe/pnputil.exe)
let ServiceProcess =
DeviceProcessEvents
| where Timestamp > ago(Lookback)
| where FileName in~ ("sc.exe","pnputil.exe","powershell.exe","pwsh.exe","wmic.exe","rundll32.exe","reg.exe")
| where isnotempty(ProcessCommandLine)
| where (
    // sc.exe create/start with driver path
    (FileName =~ "sc.exe" and ProcessCommandLine has_any ("create","start") and ProcessCommandLine has_any (WritablePaths) and ProcessCommandLine matches regex @"\.(sys|dat|bin|tmp|drv)\b")
    or
    // PowerShell New-Service / service install patterns
    ((FileName in~ ("powershell.exe","pwsh.exe")) and ProcessCommandLine has_any ("New-Service","sc.exe","CreateService","NtLoadDriver","Start-Service") and ProcessCommandLine has_any (WritablePaths))
    or
    // WMI service creation
    (FileName =~ "wmic.exe" and ProcessCommandLine has_any ("service","create") and ProcessCommandLine has_any (WritablePaths))
    or
    // PnP driver install
    (FileName =~ "pnputil.exe" and ProcessCommandLine has_any ("/add-driver","/install") and ProcessCommandLine has_any (WritablePaths))
    or
    // SetupAPI / driver install via rundll32
    (FileName =~ "rundll32.exe" and ProcessCommandLine has_any ("setupapi.dll","InstallHinfSection") and ProcessCommandLine has_any (WritablePaths))
    or
    // reg.exe writing Services ImagePath (alternate to DeviceRegistryEvents in some tenants)
    (FileName =~ "reg.exe" and ProcessCommandLine has_any ("add","HKLM\\SYSTEM\\CurrentControlSet\\Services") and ProcessCommandLine has_any (WritablePaths))
  )
| project
    DeviceId,
    ServiceTime = Timestamp,
    ServiceIndicator = ProcessCommandLine,
    ServiceValue = "",
    ServicePid = ProcessId,
    Method = "Process";

let DriverServiceCreates = union ServiceRegistry, ServiceProcess;

// 4) KERNEL LOAD (ground truth): driver actually loads
let KernelDriverLoads =
DeviceEvents
| where Timestamp > ago(Lookback)
| where ActionType == "DriverLoadEvent"
| where FolderPath has_any (WritablePaths)
// driver file name may appear as .sys even if staged differently; keep path behaviour as the anchor
| project
    DeviceId,
    KernelLoadTime = Timestamp,
    KernelDriverName = FileName,
    KernelDriverPath = FolderPath;

// 5) CORRELATION CHAIN (device-scoped; avoids brittle PID equality assumptions)
SideloadEvents
| join kind=inner (DriverDrops) on DeviceId
| where DropTime between (SideloadTime .. SideloadTime + SideloadToDropWindow)
| join kind=inner (DriverServiceCreates) on DeviceId
| where ServiceTime between (DropTime .. DropTime + DropToServiceWindow)
// Confirm the kernel load after service registration (most reliable confirmation)
| join kind=inner (KernelDriverLoads) on DeviceId
| where KernelLoadTime between (ServiceTime .. ServiceTime + ServiceToKernelWindow)

// 6) AGGREGATION (behavioural outcome)
| summarize
    FirstSeen        = min(SideloadTime),
    LastSeen         = max(KernelLoadTime),
    LoaderName       = any(LoaderName),
    LoaderPath       = any(LoaderPath),
    LoaderSigner     = any(LoaderSigner),
    LoadedModules    = make_set(LoadedModule, 10),
    LoadedSigStatus  = make_set(LoadedSigStatus, 5),
    LoadedSigners    = make_set(LoadedSigner, 10),
    DriverFiles      = make_set(DriverFile, 10),
    DriverFolders    = make_set(DriverFolder, 10),
    ServiceMethods   = make_set(Method, 5),
    ServiceIndicators= make_set(ServiceIndicator, 10),
    KernelDrivers    = make_set(KernelDriverName, 10),
    KernelPaths      = make_set(KernelDriverPath, 10),
    SampleDropperProcs = make_set(DropperProc, 10),
    SampleDropperCmds  = make_set(DropperCmd, 5)
  by DeviceId

| extend RiskScore = 95
| extend Severity = "CRITICAL"
| extend HunterDirective = strcat(
    "CRITICAL: Signed loader abuse consistent with SilverFox/ValleyRAT BYOVD chain. ",
    "Loader=", LoaderName, " (", LoaderSigner, ") from ", LoaderPath, ". ",
    "Loaded untrusted module(s)=", tostring(LoadedModules), " (sig=", tostring(LoadedSigStatus), "; signer=", tostring(LoadedSigners), "). ",
    "Staged driver-like artifact(s)=", tostring(DriverFiles), " in ", tostring(DriverFolders), ". ",
    "Service creation observed via ", tostring(ServiceMethods), ". ",
    "KERNEL CONFIRMATION: DriverLoadEvent for ", tostring(KernelDrivers), " from ", tostring(KernelPaths), ". ",
    "Action: isolate host immediately; acquire driver/module; hunt for security-tool tamper + persistence; expand scope by loader/module name across fleet."
)
| project
    FirstSeen, LastSeen, Severity, RiskScore,
    DeviceId,
    LoaderName, LoaderPath, LoaderSigner,
    LoadedModules, LoadedSigStatus, LoadedSigners,
    DriverFiles, DriverFolders,
    ServiceMethods, ServiceIndicators,
    KernelDrivers, KernelPaths,
    SampleDropperProcs, SampleDropperCmds,
    HunterDirective
| order by LastSeen desc;
